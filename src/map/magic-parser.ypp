%code requires {
#include "battle.structs.hpp"
#include "magic.structs.hpp"

#include "../lib/string.hpp"
}

%code {

#include "magic-parser.hpp"

#include "../common/utils.hpp"

#include "itemdb.hpp"
#include "magic.hpp"
#include "magic-base.hpp"
#include "magic-expr.hpp"
#include "magic-stmt.hpp"
#include "magic-lexer.hpp"
#include "script.hpp"

/// I don't know why the code is making me do this, but it is required
#define YYLEX_PARAM 0, 0

static int32_t intern_id(POD_string id_name);
static expr_t *fun_expr(const char *name, int32_t args_nr, expr_t **args, int32_t line, int32_t column);
static expr_t *dot_expr(expr_t *lhs, int32_t id);

// Note: the name must be synchronized with the 'functions' in magic-expr.cpp
#define BIN_EXPR(x, name, arg1, arg2, line, column) { expr_t *e[2]; e[0] = arg1; e[1] = arg2; x = fun_expr(name, 2, e, line, column); }

static void magic_frontend_error(const char *msg);
static void fail(int32_t line, int32_t column, const char *fmt, ...) __attribute__((format(printf, 3, 4))) __attribute__((noreturn));

static spellguard_t *spellguard_implication(spellguard_t *a, spellguard_t *b);
static effect_t *new_effect(EffectType ty);
static effect_t *set_effect_continuation(effect_t *src, effect_t *continuation);
static void add_spell(POD_string invocation, spell_t *spell, int32_t line_nr, int32_t col_nr);
static void add_teleport_anchor(POD_string name, POD_string invocation, expr_t *location, int32_t line_nr, int32_t col_nr);
static effect_t *op_effect(const char *name, int32_t args_nr, expr_t **args, int32_t line, int32_t column);

int32_t magic_frontend_lex(YYSTYPE *, YYLTYPE *);

static void install_proc(proc_t&& proc);
static effect_t *call_proc(POD_string name, int32_t args_nr, expr_t **args, int32_t line_nr, int32_t column);
static void bind_constant(POD_string name, val_t *val, int32_t line_nr, int32_t col_nr);
static val_t *find_constant(POD_string name) __attribute__((pure));

}

%name-prefix="magic_frontend_"

%locations

// YYSTYPE
%union {
    SpellFlag spell_flags;
    int32_t i;
    POD_string s;
    int32_t op;
    val_t value;
    expr_t *expr;
    e_location_t location;
    e_area_t area;
    args_rec_t arg_list;
    struct { int32_t letdefs_nr; letdef_t *letdefs; } letdefs;
    spell_t *spell;
    struct { int32_t id; SpellArgType ty; } spellarg_def;
    letdef_t vardef;
    spellguard_t *spellguard;
    component_t *components;
    struct { int32_t id, count; } component;
    effect_t *effect;
    proc_t *proc;

    SpellArgType spell_arg;
    ForEach_FilterType foreach_filter;
    Direction dir;
};

%expect 7

%token <i> INT
%token <s> STRING
%token <s> ID
%token <dir> DIR

%token '='
%token '<'
%token '>'
%token '+'
%token '-'
%token '*'
%token '/'
%token '%'
%token '@'
%token ','
%token '.'
%token ':'
%token ';'
%token '|'
%token '['
%token ']'
%token '&'
%token '^'

%token CONST
%token PROCEDURE
%token CALL
%token SILENT
%token LOCAL
%token NONMAGIC
%token SHL
%token SHR
%token EQ
%token NEQ
%token GTE
%token LTE
%token ANDAND
%token OROR
%token <s> SCRIPT_DATA
%token TO
%token TELEPORT_ANCHOR
%token SPELL
%token LET
%token IN
%token END
%token DARROW
%token STRING_TY
%token REQUIRE
%token CATALYSTS
%token COMPONENTS
%token MANA
%token CASTTIME
%token SKIP
%token ABORT
%token BREAK
%token EFFECT
%token ATEND
%token ATTRIGGER
%token PC_F
%token NPC_F
%token MOB_F
%token ENTITY_F
%token TARGET_F
%token IF
%token THEN
%token ELSE
%token FOREACH
%token FOR
%token DO
%token SLEEP

// fields used for various types
// if there is no <field> you can't use $$
%type <value> value
%type <location> location
%type <area> area
%type <arg_list> arg_list
%type <arg_list> arg_list_ne
%type <letdefs> defs
%type <spell> spelldef
%type <spellarg_def> argopt
%type <vardef> def
%type <spellguard> spellbody_list
%type <spellguard> spellbody
%type <spellguard> spellguard
%type <spellguard> spellguard_list
%type <spellguard> prereq
%type <component> item
%type <components> items
%type <components> item_list
%type <i> item_name
%type <foreach_filter> selection;
%type <effect> effect
%type <effect> effect_list
%type <effect> maybe_trigger
%type <effect> maybe_end
%type <spell_flags> spell_flags;

%type <expr> expr
%type <spell_arg> arg_ty
%type <proc> proc_formals_list
%type <proc> proc_formals_list_ne

%left OROR
%left ANDAND
%left '<' '>' GTE LTE NEQ EQ
%left '+' '-'
%left '*' '/' '%'
%left SHL SHR '&' '^' '|'
%right '='
%left OR
%left DARROW
%left '.'

%%
// void
spellconf:
/* empty */
| spellconf_option semicolons spellconf
;

// void
semicolons:
/* empty */
| semicolons ';'
;

// proc_t proc
proc_formals_list:
/* empty  */
    {
        $$ = new proc_t;
    }
| proc_formals_list_ne
    {
        $$ = $1;
    }
;

// proc_t proc
proc_formals_list_ne:
ID
    {
        $$ = new proc_t;
        $$->args.push_back(intern_id($1));
    }
| proc_formals_list_ne ',' ID
    {
        $$ = $1;
        $$->args.push_back(intern_id($3));
    }
;

// void
spellconf_option:
ID '=' expr
    {
        if (find_constant($1))
        {
            fail(@1.first_line, @1.first_column,
                 "Attempt to redefine constant `%s' as global\n",
                 $1.c_str());
            $1.free();
        }
        else
        {
            int32_t var_id = intern_id($1);
            magic_conf::vars[var_id].second = magic_default_env.magic_eval($3);
        }
    }
| CONST ID '=' expr
    {
        val_t var = magic_default_env.magic_eval($4);
        bind_constant($2, &var, @1.first_line, @1.first_column);
    }
| TELEPORT_ANCHOR ID ':' expr '=' expr
    {
        POD_string name = $2;
        POD_string invocation = magic_eval_str(&magic_default_env, $4);
        expr_t *location = $6;

        add_teleport_anchor(name, invocation, location, @1.first_line, @1.first_column);
    }
| PROCEDURE ID '(' proc_formals_list ')' '=' effect_list
    {
        proc_t *proc = $4;
        proc->name = $2;
        proc->body = $7;
        install_proc(std::move(*proc));
        delete proc;
    }
| spell_flags SPELL ID argopt ':' expr '=' spelldef
    {
        spell_t *spell = $8;
        spell->name = $3;
        POD_string invocation = magic_eval_str(&magic_default_env, $6);
        spell->arg = $4.id;
        spell->spellarg_ty = $4.ty;
        spell->flags = $1;
        add_spell(invocation, spell, @1.first_line, @1.first_column);
    }
;

// SpellFlag spell_flags
spell_flags:
/* empty */
    {
        $$ = SpellFlag();
    }
| LOCAL spell_flags
    {
        if ($2 & SpellFlag::LOCAL)
            fail(@1.first_line, @1.first_column, "`LOCAL' specified more than once");
        $$ = $2 | SpellFlag::LOCAL;
    }
| NONMAGIC spell_flags
    {
        if ($2 & SpellFlag::NONMAGIC)
            fail(@1.first_line, @1.first_column, "`NONMAGIC' specified more than once");
        $$ = $2 | SpellFlag::NONMAGIC;
    }
| SILENT spell_flags
    {
        if ($2 & SpellFlag::SILENT)
            fail(@1.first_line, @1.first_column, "`SILENT' specified more than once");
        $$ = $2 | SpellFlag::SILENT;
    }
;

// struct { int32_t id; SpellArgType ty; } spellarg_def
argopt:
/* empty */
    {
        $$.ty = SpellArgType::NONE;
    }
| '(' ID ':' arg_ty ')'
    {
        $$.id = intern_id($2);
        $$.ty = $4;
    }
;

// SpellArgType spell_arg
arg_ty:
PC_F
    {
        $$ = SpellArgType::PC;
    }
| STRING_TY
    {
        $$ = SpellArgType::STRING;
    }
;

// val_t value
value:
DIR
    {
        $$.ty = TY::DIR;
        $$.v_dir = $1;
    }
| INT
    {
        $$.ty = TY::INT;
        $$.v_int = $1;
    }
| STRING
    {
        $$.ty = TY::STRING;
        $$.v_string = $1;
    }
;

// expr_t *expr
expr:
value
    {
        $$ = magic_new_expr(ExprType::VAL);
        $$->e_val = $1;
    }
| ID
    {
        val_t *val = find_constant($1);
        if (val)
        {
            $$ = magic_new_expr(ExprType::VAL);
            $$->e_val = *val;
        }
        else
        {
            $$ = magic_new_expr(ExprType::ID);
            $$->e_id = intern_id($1);
        }
    }
| area
    {
        $$ = magic_new_expr(ExprType::AREA);
        $$->e_area = $1;
    }
| expr '+' expr
    {
        BIN_EXPR($$, "add", $1, $3, @1.first_line, @1.first_column);
    }
| expr '-' expr
    {
        BIN_EXPR($$, "sub", $1, $3, @1.first_line, @1.first_column);
    }
| expr '*' expr
    {
        BIN_EXPR($$, "mul", $1, $3, @1.first_line, @1.first_column);
    }
| expr '%' expr
    {
        BIN_EXPR($$, "mod", $1, $3, @1.first_line, @1.first_column);
    }
| expr '/' expr
    {
        BIN_EXPR($$, "div", $1, $3, @1.first_line, @1.first_column);
    }
| expr '<' expr
    {
        // notice the args are reversed
        BIN_EXPR($$, "gt", $3, $1, @1.first_line, @1.first_column);
    }
| expr '>' expr
    {
        BIN_EXPR($$, "gt", $1, $3, @1.first_line, @1.first_column);
    }
| expr '&' expr
    {
        BIN_EXPR($$, "bitand", $1, $3, @1.first_line, @1.first_column);
    }
| expr '^' expr
    {
        BIN_EXPR($$, "bitxor", $1, $3, @1.first_line, @1.first_column);
    }
| expr '|' expr
    {
        BIN_EXPR($$, "bitor", $1, $3, @1.first_line, @1.first_column);
    }
| expr SHL expr
    {
        BIN_EXPR($$, "bitshl", $1, $3, @1.first_line, @1.first_column);
    }
| expr SHR expr
    {
        BIN_EXPR($$, "bitshr", $1, $3, @1.first_line, @1.first_column);
    }
| expr LTE expr
    {
        // notice the args are reversed
        BIN_EXPR($$, "gte", $3, $1, @1.first_line, @1.first_column);
    }
| expr GTE expr
    {
        BIN_EXPR($$, "gte", $1, $3, @1.first_line, @1.first_column);
    }
| expr ANDAND expr
    {
        BIN_EXPR($$, "and", $1, $3, @1.first_line, @1.first_column);
    }
| expr OROR expr
    {
        BIN_EXPR($$, "or", $1, $3, @1.first_line, @1.first_column);
    }
| expr EQ expr
    {
        BIN_EXPR($$, "eq", $1, $3, @1.first_line, @1.first_column);
    }
| expr '=' expr
    {
        BIN_EXPR($$, "eq", $1, $3, @1.first_line, @1.first_column);
    }
| expr NEQ expr
    {
        BIN_EXPR($$, "=", $1, $3, @1.first_line, @1.first_column);
        // how does this work with the "address-of"?
        $$ = fun_expr("not", 1, &$$, @1.first_line, @1.first_column);
    }
| ID '(' arg_list ')'
    {
        $$ = fun_expr($1.c_str(), $3.args_nr, $3.args, @1.first_line, @1.first_column);
        $1.free();
    }
| '(' expr ')'
    {
        $$ = $2;
    }
| expr '.' ID
    {
        $$ = dot_expr($1, intern_id($3));
    }
;

// args_rec_t arg_list
arg_list:
/* empty */
    {
        $$.args_nr = 0;
    }
| arg_list_ne
    {
        $$ = $1;
    }
;

// args_rec_t arg_list
arg_list_ne: expr
    {
        $$.args_nr = 1;
        $$.args[0] = $1;
    }
| arg_list_ne ',' expr
    {
        if ($$.args_nr >= MAX_ARGS)
        {
            fail(@1.first_line, @1.first_column, "Too many arguments");
        }
        $$.args[$$.args_nr++] = $3;
    }
;

// e_location_t location
location:
'@' '(' expr ',' expr ',' expr ')'
    {
        $$.m = $3; $$.x = $5; $$.y = $7;
    }
;

// e_area_t area
area:
location
    {
        $$.ty = AreaType::LOCATION;
        $$.a_loc = $1;
    }
| location '@' '+' '(' expr ',' expr ')'
    {
        $$.ty = AreaType::RECT;
        $$.a_rect.loc = $1;
        $$.a_rect.width = $5;
        $$.a_rect.height = $7;
    }
;

// spell_t *spell
spelldef:
spellbody_list
    {
        $$ = new spell_t($1);
    }
| LET defs IN spellbody_list
    {
        $$ = new spell_t($4);
        $$->letdefs_nr = $2.letdefs_nr;
        $$->letdefs = $2.letdefs;
        $$->spellguard = $4;
    }
;

// struct { int32_t letdefs_nr; letdef_t *letdefs; } letdefs
defs:
semicolons
    {
        $$.letdefs_nr = 0;
        CREATE($$.letdefs, letdef_t, 1);
    }
| defs def semicolons
    {
        $$ = $1;
        $$.letdefs_nr++;
        RECREATE($$.letdefs, letdef_t, $$.letdefs_nr);
        $$.letdefs[$1.letdefs_nr] = $2;
    }
;

// letdef_t vardef
def:
ID '=' expr
    {
        if (find_constant($1))
        {
            fail(@1.first_line, @1.first_column,
                 "Attempt to re-define constant `%s' as LET-bound variable.\n",
                 $1.c_str());
            $1.free();
        }
        else
        {
            $$.id = intern_id($1);
            $$.expr = $3;
        }
    }
;

// spellguard_t *spellguard
spellbody_list:
spellbody
    {
        $$ = $1;
    }
| spellbody '|' spellbody_list
    {
        spellguard_t *sg = new spellguard_t(SpellGuardType::CHOICE);
        sg->next = $1;
        sg->s_alt = $3;
        $$ = sg;
    }
;

// spellguard_t *spellguard
spellbody:
spellguard DARROW spellbody
    {
        $$ = spellguard_implication($1, $3);
    }
| '(' spellbody_list ')'
    {
        $$ = $2;
    }
| EFFECT effect_list maybe_trigger maybe_end
    {
        spellguard_t *sg = new spellguard_t(SpellGuardType::EFFECT);
        sg->s_effect.effect = $2;
        sg->s_effect.at_trigger = $3;
        sg->s_effect.at_end = $4;
        $$ = sg;
    }
;

// effect_t *effect
maybe_trigger:
/* empty */
    {
        $$ = NULL;
    }
| ATTRIGGER effect_list
    {
        $$ = $2;
    }
;

// effect_t *effect
maybe_end:
/* empty */
    {
        $$ = NULL;
    }
| ATEND effect_list
    {
        $$ = $2;
    }
;

// spellguard_t *spellguard
spellguard:
prereq
    {
        $$ = $1;
    }
| spellguard OR spellguard
    {
        spellguard_t *sg = new spellguard_t(SpellGuardType::CHOICE);
        sg->next = $1;
        sg->s_alt = $3;
        $$ = sg;
    }
| '(' spellguard_list ')'
    {
        $$ = $2;
    }
;

// spellguard_t *spellguard
spellguard_list:
spellguard
    {
        $$ = $1;
    }
| spellguard ',' spellguard_list
    {
        $$ = spellguard_implication($1, $3);
    }
;

// spellguard_t *spellguard
prereq:
REQUIRE expr
    {
        $$ = new spellguard_t(SpellGuardType::CONDITION);
        $$->s_condition = $2;
    }
| CATALYSTS items
    {
        $$ = new spellguard_t(SpellGuardType::CATALYSTS);
        $$->s_catalysts = $2;
    }
| COMPONENTS items
    {
        $$ = new spellguard_t(SpellGuardType::COMPONENTS);
        $$->s_components = $2;
    }
| MANA expr
    {
        $$ = new spellguard_t(SpellGuardType::MANA);
        $$->s_mana = $2;
    }
| CASTTIME expr
    {
        $$ = new spellguard_t(SpellGuardType::CASTTIME);
        $$->s_casttime = $2;
    }
;

// component_t *components
items: '[' item_list ']'
    {
        $$ = $2;
    }
;

// component_t *components
item_list: item
    {
        $$ = NULL;
        magic_add_component($$, $1.id, $1.count);
    }
| item_list ',' item
    {
        $$ = $1;
        magic_add_component($$, $3.id, $3.count);
    }
;

// struct {int32_t id, count; } component;
item:
INT '*' item_name
    {
        $$.id = $3; $$.count = $1;
    }
| item_name
    {
        $$.id = $1; $$.count = 1;
    }
;

// int32_t i
item_name:
STRING
    {
        struct item_data *item = itemdb_searchname($1.c_str());
        if (!item)
        {
            fail(@1.first_line, @1.first_column, "Unknown item `%s'\n", $1.c_str());
            $$ = 0;
        }
        else
            $$ = item->nameid;
        $1.free();
    }
| INT
    {
        $$ = $1;
    }
;

// ForEach_FilterType foreach_filter
selection:
PC_F
    {
        $$ = ForEach_FilterType::PC;
    }
| MOB_F
    {
        $$ = ForEach_FilterType::MOB;
    }
| ENTITY_F
    {
        $$ = ForEach_FilterType::ENTITY;
    }
| SPELL
    {
        $$ = ForEach_FilterType::SPELL;
    }
| TARGET_F
    {
        $$ = ForEach_FilterType::TARGET;
    }
| NPC_F
    {
        $$ = ForEach_FilterType::NPC;
    }
;

// effect_t *effect
effect:
'(' effect_list ')'
    {
        $$ = $2;
    }
| SKIP ';'
    {
        $$ = new_effect(EffectType::SKIP);
    }
| ABORT ';'
    {
        $$ = new_effect(EffectType::ABORT);
    }
| END ';'
    {
        $$ = new_effect(EffectType::END);
    }
| BREAK ';'
    {
        $$ = new_effect(EffectType::BREAK);
    }
| ID '=' expr ';'
    {
        if (find_constant($1))
        {
            fail(@1.first_line, @1.first_column,
                 "Attempt to re-define constant `%s' in assignment.",
                 $1.c_str());
            $1.free();
        }
        else
        {
            $$ = new_effect(EffectType::ASSIGN);
            $$->e_assign.id = intern_id($1);
            $$->e_assign.expr = $3;
        }
    }
| FOREACH selection ID IN expr DO effect
    {
        $$ = new_effect(EffectType::FOREACH);
        $$->e_foreach.var_id = intern_id($3);
        $$->e_foreach.area = $5;
        $$->e_foreach.body = $7;
        $$->e_foreach.filter = $2;
    }
| FOR ID '=' expr TO expr DO effect
    {
        $$ = new_effect(EffectType::FOR);
        $$->e_for.var_id = intern_id($2);
        $$->e_for.start = $4;
        $$->e_for.stop = $6;
        $$->e_for.body = $8;
    }
| IF expr THEN effect ELSE effect
    {
        $$ = new_effect(EffectType::IF);
        $$->e_if.cond = $2;
        $$->e_if.true_branch = $4;
        $$->e_if.false_branch = $6;
    }
| IF expr THEN effect
    {
        $$ = new_effect(EffectType::IF);
        $$->e_if.cond = $2;
        $$->e_if.true_branch = $4;
        $$->e_if.false_branch = new_effect(EffectType::SKIP);
    }
| SLEEP expr ';'
    {
        $$ = new_effect(EffectType::SLEEP);
        $$->e_sleep = $2;
    }
| ID '(' arg_list ')' ';'
    {
        $$ = op_effect($1.c_str(), $3.args_nr, $3.args, @1.first_line, @1.first_column);
        $1.free();
    }
| SCRIPT_DATA
    {
        $$ = new_effect(EffectType::SCRIPT);
        $$->e_script = parse_script($1.c_str(), @1.first_line);
        $1.free();
        if ($$->e_script == NULL)
            fail(@1.first_line, @1.first_column, "Failed to compile script\n");
    }
| CALL ID '(' arg_list ')' ';'
    {
        $$ = call_proc($2, $4.args_nr, $4.args, @1.first_line, @1.first_column);
        $2.free();
    }
;

// effect_t *effect
effect_list:
/* empty */
    {
        $$ = new_effect(EffectType::SKIP);
    }
| effect semicolons effect_list
    {
        $$ = set_effect_continuation($1, $3);
    }
;

%%

static int32_t intern_id(POD_string id_name)
{
    size_t sz = magic_conf::vars.size();
    for (int32_t i = 0; i < sz; i++)
        if (id_name == magic_conf::vars[i].first)
        {
            id_name.free();
            return i;
        }

    int32_t i = sz;
    // Must add new
    magic_conf::vars.push_back(std::make_pair(id_name, val_t{{0}, TY::UNDEF}));

    return i;
}

void add_spell(POD_string invocation, spell_t *spell, int32_t line_nr, int32_t col_nr)
{
    if (magic_conf::spell_names.find(spell->name) != magic_conf::spell_names.end())
    {
        fail(line_nr, col_nr, "Attempt to redefine spell `%s'\n", spell->name.c_str());
        return;
    }

    auto it = magic_conf::spells.find(invocation);
    if (it != magic_conf::spells.end())
    {
        fail(line_nr, col_nr,
             "Attempt to redefine spell invocation `%s' as `%s'\n",
             invocation.c_str(),
             spell->name.c_str());
        return;
    }
    // FIXME: this could be slightly more efficient if we had a "nearby" iterator
    magic_conf::spell_names[spell->name] = invocation;
    magic_conf::spells[invocation] = spell;
}

void add_teleport_anchor(POD_string name, POD_string invocation, expr_t *location, int32_t line_nr, int32_t col_nr)
{
    if (magic_conf::anchor_names.find(name) != magic_conf::anchor_names.end())
    {
        fail(line_nr, col_nr, "Attempt to redefine teleport anchor `%s'\n", name.c_str());
        return;
    }

    auto it = magic_conf::anchors.find(invocation);
    if (it != magic_conf::anchors.end())
    {
        fail(line_nr, col_nr,
             "Attempt to redefine anchor invocation `%s' as `%s'\n",
             invocation.c_str(),
             name.c_str());
    }

    val_t val = magic_default_env.magic_eval(location);
    if (val.ty != TY::AREA)
        abort();
    magic_conf::anchors[invocation] = val.v_area;
}


static void fail(int32_t line, int32_t column, const char *fmt, ...)
{
    va_list ap;
    fprintf(stderr, "[magic-init]  L%d:%d: ", line, column);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    abort();
}

static expr_t *dot_expr(expr_t *expr, int32_t id)
{
    expr_t *retval = magic_new_expr(ExprType::SPELLFIELD);
    retval->e_field.id = id;
    retval->e_field.expr = expr;

    return retval;
}

static expr_t *fun_expr(const char *name, int32_t args_nr, expr_t **args, int32_t line, int32_t column)
{
    const std::pair<const std::string, fun_t> *fun = magic_get_fun(name);

    if (!fun)
    {
        fail(line, column, "Unknown function `%s'\n", name);
    }
    if (strlen(fun->second.signature) != args_nr)
    {
        fail(line, column, "Incorrect number of arguments to function `%s': Expected %d, found %d\n",
             name, strlen(fun->second.signature), args_nr);
    }

    expr_t *expr = magic_new_expr(ExprType::FUNAPP);
    expr->e_funapp.line_nr = line;
    expr->e_funapp.column = column;
    expr->e_funapp.fun = fun;
    expr->e_funapp.args_nr = args_nr;

    for (int32_t i = 0; i < args_nr; i++)
        expr->e_funapp.args[i] = args[i];

    return expr;
}

int32_t spell_t::spell_counter;

spell_t::spell_t(spellguard_t *guard) : idx(++spell_counter), spellguard(guard) {}

spellguard_t::spellguard_t(SpellGuardType type) : ty(type) {}

static spellguard_t *spellguard_implication(spellguard_t *a, spellguard_t *b)
{
    spellguard_t *retval = a;

    /* This can happen due to reference sharing:
     * e.g.,
     *  (R0 -> (R1 | R2)) => (R3)
     * yields
     *  (R0 -> (R1 -> R3 | R2 -> R3))
     *
     * So if we now add => R4 to that, we want
     *  (R0 -> (R1 -> R3 -> R4 | R2 -> R3 -> R4))
     *
     * but we only need to add it once, because the R3 reference is shared.
     */
    if (a == b)
        return retval;

    /* If the premise is a disjunction, b is the continuation of _all_ branches */
    if (a->ty == SpellGuardType::CHOICE)
        spellguard_implication(a->s_alt, b);
    if (a->next)
        spellguard_implication(a->next, b);
    else
        a->next = b;

    return retval;
}

static effect_t *new_effect(EffectType ty)
{
    effect_t *effect;
    CREATE(effect, effect_t, 1);
    effect->ty = ty;
    return effect;
}

static effect_t *set_effect_continuation(effect_t *src, effect_t *continuation)
{
    effect_t *retval = src;
    /* This function is completely analogous to `spellguard_implication' above; read the control flow implications above first before pondering it. */

    if (src == continuation)
        return retval;

    /* For FOR and FOREACH, we use special stack handlers and thus don't have to set
     * the continuation.  It's only IF that we need to handle in this fashion. */
    if (src->ty == EffectType::IF)
    {
        set_effect_continuation(src->e_if.true_branch, continuation);
        set_effect_continuation(src->e_if.false_branch, continuation);
    }
    if (src->next)
        set_effect_continuation(src->next, continuation);
    else
        src->next = continuation;

    return retval;
}

static effect_t *op_effect(const char *name, int32_t args_nr, expr_t **args, int32_t line, int32_t column)
{
    const std::pair<const std::string, op_t> *op = magic_get_op(name);

    if (!op)
        fail(line, column, "Unknown operation `%s'\n", name);
    else if (strlen(op->second.signature) != args_nr)
        fail(line, column,
             "Incorrect number of arguments to operation `%s': Expected %d, found %d\n",
             name, strlen(op->second.signature), args_nr);

    effect_t *effect = new_effect(EffectType::OP);
    effect->e_op.line_nr = line;
    effect->e_op.column = column;
    effect->e_op.op = op;
    effect->e_op.args_nr = args_nr;

    for (int32_t i = 0; i < args_nr; i++)
        effect->e_op.args[i] = args[i];

    return effect;
}

std::map<POD_string, proc_t> procs;

static void install_proc(proc_t&& proc)
{
    procs[proc.name] = proc;
}

static effect_t *call_proc(POD_string name, int32_t args_nr, expr_t **args, int32_t line_nr, int32_t column)
{
    auto it = procs.find(name);
    if (it == procs.end())
    {
        fail(line_nr, column,
             "Unknown procedure `%s'\n",
             name.c_str());
        return new_effect(EffectType::SKIP);
    }

    proc_t *p = &it->second;
    if (p->args.size() != args_nr)
    {
        fail(line_nr, column,
             "Procedure %s/%zd invoked with %d parameters\n",
             name.c_str(), p->args.size(), args_nr);
    }

    effect_t *retval = new_effect(EffectType::CALL);
    retval->e_call.body = p->body;
    retval->e_call.args_nr = args_nr;
    // hm, this would be a copy and I don't see why it should be necessary
    retval->e_call.formals = p->args;
    retval->e_call.actuals = args;
    return retval;
}

struct const_def_rec
{
    POD_string name;
    val_t val;
};
std::vector<const_def_rec> const_defs;

void bind_constant(POD_string name, val_t *val, int32_t line_nr, int32_t col_nr)
{
    if (find_constant(name))
    {
        fail(line_nr, col_nr, "Redefinition of constant `%s'\n", name.c_str());
        return;
    }

    const_defs.push_back({name, *val});
}

static val_t *find_constant(POD_string name)
{
    for (int32_t i = 0; i < const_defs.size(); i++)
    {
        if (const_defs[i].name == name)
        {
            return &const_defs[i].val;
        }
    }

    return NULL;
}


static void INTERN_ASSERT(const char *name, int32_t id)
{
    POD_string pname = NULL;
    pname.assign(name);
    int32_t zid = intern_id(pname);
    if (zid != id)
        fprintf(stderr,
                "[magic-conf] INTERNAL ERROR: Builtin special var %s interned to %d, not %d as it should be!\n",
                name, zid, id);
}

// must be called after itemdb initialisation
void magic_init(const char *conffile)
{
    //magic_conf::obscure_chance = 95;
    //magic_conf::min_casttime = 100;

    // it would be better to specify these in an initializer list
    INTERN_ASSERT("min_casttime", Var::MIN_CASTTIME);
//     INTERN_ASSERT("obscure_chance", Var::OBSCURE_CHANCE);
    INTERN_ASSERT("caster", Var::CASTER);
    INTERN_ASSERT("spellpower", Var::SPELLPOWER);
    INTERN_ASSERT("self_spell", Var::SPELL);
    INTERN_ASSERT("self_invocation", Var::INVOCATION);
    INTERN_ASSERT("target", Var::TARGET);
    INTERN_ASSERT("script_target", Var::SCRIPTTARGET);
    INTERN_ASSERT("location", Var::LOCATION);

    magic_frontend_in = fopen(conffile, "r");
    if (!magic_frontend_in)
    {
        fprintf(stderr, "[magic-conf] Magic configuration file `%s' not found -> no magic.\n", conffile);
        return;
    }
    magic_frontend_parse();
    if (magic_conf::vars[Var::MIN_CASTTIME].second.ty == TY::INT)
        magic_conf::min_casttime = magic_conf::vars[Var::MIN_CASTTIME].second.v_int;
//     if (magic_conf::vars[Var::OBSCURE_CHANCE].ty == TY::INT)
//         magic_conf::obscure_chance = magic_conf::vars[Var::OBSCURE_CHANCE].v_int;

    printf("[magic-conf] Magic initialised: %d spells, %d teleport anchors.\n",
           magic_conf::spells.size(), magic_conf::anchors.size());

    procs.clear();
}

static void magic_frontend_error(const char *msg)
{
    fprintf(stderr, "[magic-conf] Parse error: %s at line %d\n", msg, magic_frontend_lineno);
    abort();
}
